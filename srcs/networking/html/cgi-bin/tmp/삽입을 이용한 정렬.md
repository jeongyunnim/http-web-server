----
> 레코드를 정렬하기 전에 그 이전의 레코드가 이미 정렬되어 있다고 가정한다. 정렬된 레코드 중 적절한 위치에 해당 요소를 삽입한다.

- ### 직접 삽입(straight insertion)
	- 알고리즘 개요
		 - 가장 단순한 삽입 정렬
		- 1 < j <= N 이며 R_1...R_(j-1)이 K_1 <= K_2... <= K_(j-1)임을 만족하는 형태로 정렬되어 있음을 가정한다.
		- 삽입할 요소의 키 K_j를 하위 정렬된 요소들과 비교하면서 새 요소를 넣을 자리를 찾는다. 
		- 삽입할 위치 이후의 값을 하나씩 밀어주고 해당 요소를 삽입해준다.
		- 비교와 이동 연산을 결합해서 진행하는 것이 편하다.
		- 새로운 요소는 '자신의 적절한 수준에 안착하기 때문에 체로 *내리기(sifting)* 또는 *가라앉히기(sinking)* 기법이라고 부른다.'
	- 알고리즘 프레임워크
		- S: 직접 삽입 정렬. 레코드들을 그 자리에서 재배치한다. 이 알고리즘을 수행한 뒤 레코드 키들은 오름차순으로 정렬된다.
		- S1: for (j = 2; j < N: j++) S2부터 S5까지 수행한 뒤 알고리즘을 종료한다.
		- S2: i = j - 1; K = K\[j]; R = R\[j]; 초기화.
		- S3: if(K >= K\[i]) S5로 간다.
		- S4: else { R\[i + 1] = R\[i]; i--;}
		- S5: R\[i + 1] = R\[i];
	- 실행시간
		- 9B + 10N - 3A - 9
		- N: 레코드 개수
		- A: N개의 객체 집합에서 두 개를 선택하는 방법의 수.(N^2 - N) / 2
		- B: 수열 K\[i]..K\[N]의 반전의 개수
	- 비교 횟수
		- (1 + 2 + 3 + 4 .... N) / 2 '=. 1/4\*N^2

- ### 이진 삽입과 양방향 삽입 
	- 6.2.1 [[이진 검색]] 기법을 공부한다. 그를 통해 j번째 항목의 삽입 위치 선택을 최적화 할 수 있다.
		- 이 방법을 **이진 삽입**이라고 부른다.
		- 비교 횟수는 약 NlogN이다. 이는 1/4\*N^2보다 훨씬 효율적인 방식이라고 할 수 있다.
		- 이진 삽입은 전체 정렬 문제의 절반만 해결한다. 요소의 삽입할 위치를 찾았지만, 삽입을 위해서는 해당 위치를 비우기 위하여 데이터를 밀어서 저장해야 하는 문제가 발생한다.
		- 따라서 총 실행시간은 여전히 N^2에 비례한다.
	- 첫 번째 항목을 가운데에 놓고 삽입하는 항목들을 왼쪽 오른쪽으로 보내 양 방향으로 삽입하게 한다.
		- 더 흥미로운 기법들이 개발되어 자세한 설명 생략한댄다.
- ### 셸 정렬
	- 알고리즘 개요
	- 각 레코드를 개별적으로 정렬한다.
		- 2개 씩 8개로 나눈 뒤 정렬한다.
			- (R\[1], R\[9]), (R\[2], R\[10]), (R\[3], R\[11]), (R\[4], R\[12])..., (R\[8], R\[16])
		- 4개 씩 4개로 나눈 뒤 정렬한다.
			- (R\[1], R\[5], R\[9], R\[14]), ... , (R\[4], R\[8], R\[12], R\[16])
			- 레코드 16개를 모두 정렬한다.
		- 여덟 레코드들의 그룹 두 개를 정렬한다.
		- 레코드 16개를 모두 정렬해서 정렬을 마친다.
	- 이러한 방식에서 레코드들이 최종 목적지로 빠르게 도달하는 경향이 있다.
- ### 목록 정렬
	- 직접 삽입의 연산
		1) 순서 있는 파일을 탐색하며 주어진 키보다 작거나 같은 가장 큰 키를 찾는다.
		2) 순서 있는 파일의 특정 부분에 새 항목을 삽입한다.
		- 각 삽입 연산을 수행하기 위해서 정렬된 레코드 중 약 절반을 이동 해야한다.
	- 자료구조를 연결리스트로 선택하여 서로의 포인터만 새로 변경해주는 알고리즘.
	- 트리구조의 배치를 사용하면 더 효율적으로 구성이 가능하다.
		- 메모리 이동을 해야하기 전까지는 양방향 삽입으로 구현하고, 자료를 이동해야 하는 경우 메모리 영역을 가리키는 포인터를 삽입한다. 
	- 일반적으로 긴 검색이 필요한 연산들을 한 데 묶어서 여러 연산이 함께 수행되도록 하는 것이 좋다.
- ### 주소 계산 정렬
	- 주소 계산 정렬은 N에 비례한는 추가적인 저장공간을 요구한다.
	- 목록 삽입을 하나의 목록이 아니라 여러 개의 목록들을 두는 것으로 일반화할 수 있다. 
	- 비슷한 범위의 수 끼리 뭉쳐있다고 가정한 뒤 정렬하는 방법
